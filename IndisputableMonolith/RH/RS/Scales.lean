import Mathlib
import IndisputableMonolith.Constants

namespace IndisputableMonolith
namespace RH
namespace RS

/-! Binary scales and φ-exponential wrappers -/

/-- Binary scale factor `B = 2^k` as a real. -/
def B_of (k : Nat) : ℝ := (2 : ℝ) ^ k

@[simp] lemma B_of_zero : B_of 0 = 1 := by simp [B_of]

@[simp] lemma B_of_succ (k : Nat) : B_of (k+1) = 2 * B_of k := by
  simp [B_of, pow_succ, mul_comm]

lemma B_of_pos (k : Nat) : 0 < B_of k := by
  have : 0 < (2:ℝ) := by norm_num
  simpa [B_of] using pow_pos this k

@[simp] lemma B_of_one : B_of 1 = 2 := by simp [B_of]

lemma one_le_B_of (k : Nat) : (1 : ℝ) ≤ B_of k := by
  induction k with
  | zero => simp [B_of]
  | succ k ih =>
      have hmul : (2 : ℝ) ≤ 2 * B_of k := by
        have : 2 * (1 : ℝ) ≤ 2 * B_of k := by
          have hnonneg : 0 ≤ (2 : ℝ) := by norm_num
          exact mul_le_mul_of_nonneg_left ih hnonneg
        simpa using this
      have h12 : (1 : ℝ) ≤ 2 := by norm_num
      have : (1 : ℝ) ≤ 2 * B_of k := le_trans h12 hmul
      simpa [B_of_succ, mul_comm] using this

/-- Two to an integer power: 2^k for k ∈ ℤ. -/
noncomputable def twoPowZ (k : Int) : ℝ :=
  if 0 ≤ k then (2 : ℝ) ^ (Int.toNat k)
  else 1 / ((2 : ℝ) ^ (Int.toNat (-k)))

@[simp] lemma twoPowZ_zero : twoPowZ 0 = 1 := by simp [twoPowZ]
@[simp] lemma twoPowZ_ofNat (k : Nat) : twoPowZ (Int.ofNat k) = (2 : ℝ) ^ k := by simp [twoPowZ]
@[simp] lemma twoPowZ_negSucc (k : Nat) : twoPowZ (Int.negSucc k) = 1 / ((2 : ℝ) ^ k.succ) := by
  simp [twoPowZ]

/-- φ-power wrapper. -/
noncomputable def PhiPow (x : ℝ) : ℝ := Real.exp (Real.log (Constants.phi) * x)

lemma PhiPow_add (x y : ℝ) : PhiPow (x + y) = PhiPow x * PhiPow y := by
  unfold PhiPow
  have hx : Real.log (Constants.phi) * (x + y)
        = Real.log (Constants.phi) * x + Real.log (Constants.phi) * y := by
    ring
  simpa [hx, Real.exp_add]

lemma PhiPow_sub (x y : ℝ) : PhiPow (x - y) = PhiPow x / PhiPow y := by
  unfold PhiPow
  have hx : Real.log (Constants.phi) * (x - y)
        = Real.log (Constants.phi) * x + Real.log (Constants.phi) * (-y) := by
    ring
  calc
    Real.exp (Real.log (Constants.phi) * (x - y))
        = Real.exp (Real.log (Constants.phi) * x + Real.log (Constants.phi) * (-y)) := by
              simpa [hx]
    _   = Real.exp (Real.log (Constants.phi) * x)
            * Real.exp (Real.log (Constants.phi) * (-y)) := by
              simp [Real.exp_add]
    _   = Real.exp (Real.log (Constants.phi) * x)
            * (Real.exp (Real.log (Constants.phi) * y))⁻¹ := by
              simp [Real.exp_neg]
    _   = Real.exp (Real.log (Constants.phi) * x)
            / Real.exp (Real.log (Constants.phi) * y) := by
              simp [div_eq_mul_inv]

@[simp] lemma PhiPow_zero : PhiPow 0 = 1 := by
  unfold PhiPow; simp

@[simp] lemma PhiPow_one : PhiPow 1 = Constants.phi := by
  unfold PhiPow
  have hφ : 0 < Constants.phi := Constants.phi_pos
  simp [one_mul, Real.exp_log hφ]

@[simp] lemma PhiPow_neg (y : ℝ) : PhiPow (-y) = 1 / PhiPow y := by
  have := PhiPow_sub 0 y
  simpa [PhiPow_zero, sub_eq_add_neg] using this

@[simp] noncomputable def lambdaA : ℝ := Real.log Constants.phi
@[simp] noncomputable def kappaA  : ℝ := Constants.phi

@[simp] noncomputable def F_ofZ (Z : ℤ) : ℝ := (Real.log (1 + (Z : ℝ) / kappaA)) / lambdaA

@[simp] def Z_quark (Q : ℤ) : ℤ := 4 + (6 * Q) ^ (2 : Nat) + (6 * Q) ^ (4 : Nat)
@[simp] def Z_lepton (Q : ℤ) : ℤ := (6 * Q) ^ (2 : Nat) + (6 * Q) ^ (4 : Nat)
@[simp] def Z_neutrino : ℤ := 0

lemma kappaA_pos : 0 < kappaA := by
  unfold kappaA; simpa using Constants.phi_pos

lemma lambdaA_ne_zero : lambdaA ≠ 0 := by
  have hpos : 0 < Constants.phi := Constants.phi_pos
  have hne1 : Constants.phi ≠ 1 := Constants.phi_ne_one
  simpa [lambdaA] using Real.log_ne_zero_of_pos_of_ne_one hpos hne1

lemma kappaA_ne_zero : kappaA ≠ 0 := by
  simpa [kappaA] using Constants.phi_ne_zero

/-! Ledger units (δ subgroup) -/
namespace LedgerUnits

/-- The subgroup of ℤ generated by δ. We specialize to δ = 1 for a clean order isomorphism. -/
def DeltaSub (δ : ℤ) := {x : ℤ // ∃ n : ℤ, x = n * δ}

/-- Embed ℤ into the δ=1 subgroup. -/
def fromZ_one (n : ℤ) : DeltaSub 1 := ⟨n, by exact ⟨n, by simpa using (Int.mul_one n)⟩⟩

/-- Project from the δ=1 subgroup back to ℤ by taking its value. -/
def toZ_one (p : DeltaSub 1) : ℤ := p.val

@[simp] lemma toZ_fromZ_one (n : ℤ) : toZ_one (fromZ_one n) = n := rfl

@[simp] lemma fromZ_toZ_one (p : DeltaSub 1) : fromZ_one (toZ_one p) = p := by
  cases p with
  | mk x hx =>
    apply Subtype.ext
    rfl

/-- Explicit equivalence between the δ=1 subgroup and ℤ (mapping n·1 ↦ n). -/
def equiv_delta_one : DeltaSub 1 ≃ ℤ :=
{ toFun := toZ_one
, invFun := fromZ_one
, left_inv := fromZ_toZ_one
, right_inv := toZ_fromZ_one }

end LedgerUnits

/-! Affine maps for unit-to-scale projections -/
namespace Scales

/-- Affine map from ℤ to ℝ: n ↦ slope·n + offset. -/
structure AffineMapZ where
  slope : ℝ
  offset : ℝ

@[simp] def apply (f : AffineMapZ) (n : ℤ) : ℝ := f.slope * (n : ℝ) + f.offset

/-- Map δ-subgroup to ℝ by composing an affine map with a provided projection to ℤ. -/
noncomputable def mapDelta (δ : ℤ) (hδ : δ ≠ 0)
  (toZ : {x : ℤ // ∃ n : ℤ, x = n * δ} → ℤ) (f : AffineMapZ) :
  {x : ℤ // ∃ n : ℤ, x = n * δ} → ℝ :=
  fun p => f.slope * ((toZ p) : ℝ) + f.offset

/-- Context constructors: charge (quantum `qe`), time (τ0), and action (ħ). -/
@[simp] def chargeMap (qe : ℝ) : AffineMapZ := { slope := qe, offset := 0 }
@[simp] def timeMap (U : Constants.RSUnits) : AffineMapZ := { slope := U.tau0, offset := 0 }
-- actionMap omitted in minimal RSUnits (no `hbar` field)

@[simp] lemma apply_chargeMap (qe : ℝ) (n : ℤ) :
  apply (chargeMap qe) n = qe * (n : ℝ) := by simp [apply, chargeMap]

@[simp] lemma apply_timeMap (U : Constants.RSUnits) (n : ℤ) :
  apply (timeMap U) n = U.tau0 * (n : ℝ) := by simp [apply, timeMap]

-- (no actionMap in minimal RSUnits)

/-- Specialization of `mapDelta` to δ = 1 using the canonical projection. -/
noncomputable def mapDeltaOne
  (toZ : LedgerUnits.DeltaSub 1 → ℤ) (f : AffineMapZ) : LedgerUnits.DeltaSub 1 → ℝ :=
  fun p => f.slope * ((toZ p) : ℝ) + f.offset

@[simp] lemma mapDeltaOne_fromZ_one
  (f : AffineMapZ) (n : ℤ) :
  mapDeltaOne LedgerUnits.toZ_one f (LedgerUnits.fromZ_one n)
    = f.slope * (n : ℝ) + f.offset := by
  simp [mapDeltaOne, LedgerUnits.toZ_one, LedgerUnits.fromZ_one]

lemma mapDeltaOne_step (f : AffineMapZ) (n : ℤ) :
  mapDeltaOne LedgerUnits.toZ_one f (LedgerUnits.fromZ_one (n+1))
    - mapDeltaOne LedgerUnits.toZ_one f (LedgerUnits.fromZ_one n) = f.slope := by
  simp [mapDeltaOne, add_comm, add_left_comm, add_assoc, sub_eq_add_neg, mul_add]

@[simp] lemma mapDeltaTime_fromZ_one
  (U : Constants.RSUnits) (n : ℤ) :
  mapDeltaOne LedgerUnits.toZ_one (timeMap U) (LedgerUnits.fromZ_one n)
    = U.tau0 * (n : ℝ) := by
  simp [mapDeltaOne, timeMap, add_comm]

-- (no actionMap in minimal RSUnits)

end Scales

end RS
end RH
end IndisputableMonolith
