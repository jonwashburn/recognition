import Mathlib
import IndisputableMonolith.Constants
import IndisputableMonolith.Streams
import IndisputableMonolith.Patterns
import IndisputableMonolith.RH.RS.Bands
import IndisputableMonolith.RH.RS.Anchors
import IndisputableMonolith.RH.RS.Scales
import IndisputableMonolith.Complexity.VertexCover
import IndisputableMonolith.Complexity.RSVC
import IndisputableMonolith.URCGenerators
import IndisputableMonolith.Complexity.BalancedParityHidden
import IndisputableMonolith.Bridge.BridgeData
import IndisputableMonolith.Recognition
import IndisputableMonolith.Verification
import IndisputableMonolith.Verification.DEC

namespace IndisputableMonolith
/-! ### Core stable props and helpers moved from the monolith -/

/-! #### Ethics invariants -/
namespace Ethics
namespace Invariants

def Monotonicity : Prop := True
def Symmetry     : Prop := True
def Stability    : Prop := True

def All : Prop := Monotonicity ∧ Symmetry ∧ Stability

lemma monotonicity_holds : Monotonicity := True.intro
lemma symmetry_holds     : Symmetry     := True.intro
lemma stability_holds    : Stability    := True.intro

lemma all_holds : All := And.intro monotonicity_holds (And.intro symmetry_holds stability_holds)

end Invariants
end Ethics

/‑! #### Constants (minimal) -/
open Constants

/-! Patterns moved to submodule -/

/-! (Streams moved to `IndisputableMonolith/Streams.lean`) -/

/‑! #### URC adapters: stable Prop wrappers -/

/-- Units identity: c·τ0 = ℓ0 for all anchors. -/
def units_identity_prop : Prop :=
  ∀ U : Constants.RSUnits, U.c * U.tau0 = U.ell0

lemma units_identity_holds : units_identity_prop := by
  intro U; simpa using U.c_ell0_tau0

/-- Eight‑beat existence (period exactly 8). -/
def eightbeat_prop : Prop := ∃ w : Patterns.CompleteCover 3, w.period = 8

lemma eightbeat_holds : eightbeat_prop := by
  simpa using Patterns.period_exactly_8

-- (EL/Jlog wrappers omitted in Core to keep dependencies minimal.)

-- (Recognition lower-bound wrapper omitted in Core; depends on heavy external proofs.)

/-! Verification moved to submodule -/

/-! #### RH.RS bands foundation -/
namespace RH
namespace RS

-- Bands, Anchors, and Scales moved to submodules

/- Moved: B_of, twoPowZ, LedgerUnits, PhiPow/lambdaA/kappaA, F_ofZ, Z_* -/

@[simp] lemma B_of_zero : B_of 0 = 1 := by simp [B_of]

@[simp] lemma B_of_succ (k : Nat) : B_of (k+1) = 2 * B_of k := by
  simp [B_of, pow_succ, mul_comm]

lemma B_of_pos (k : Nat) : 0 < B_of k := by
  have : 0 < (2:ℝ) := by norm_num
  simpa [B_of] using pow_pos this k

@[simp] lemma B_of_one : B_of 1 = 2 := by simp [B_of]

/-- Lower bound: `B_of k = 2^k ≥ 1`. -/
lemma one_le_B_of (k : Nat) : (1 : ℝ) ≤ B_of k := by
  induction k with
  | zero => simp [B_of]
  | succ k ih =>
      have hmul : (2 : ℝ) ≤ 2 * B_of k := by
        have : 2 * (1 : ℝ) ≤ 2 * B_of k := by
          have hnonneg : 0 ≤ (2 : ℝ) := by norm_num
          exact mul_le_mul_of_nonneg_left ih hnonneg
        simpa using this
      have h12 : (1 : ℝ) ≤ 2 := by norm_num
      have : (1 : ℝ) ≤ 2 * B_of k := le_trans h12 hmul
      simpa [B_of_succ, mul_comm] using this

/-- Two to an integer power: 2^k for k ∈ ℤ. -/
noncomputable def twoPowZ (k : Int) : ℝ :=
  if 0 ≤ k then (2 : ℝ) ^ (Int.toNat k)
  else 1 / ((2 : ℝ) ^ (Int.toNat (-k)))

@[simp] lemma twoPowZ_zero : twoPowZ 0 = 1 := by
  simp [twoPowZ]

@[simp] lemma twoPowZ_ofNat (k : Nat) : twoPowZ (Int.ofNat k) = (2 : ℝ) ^ k := by
  simp [twoPowZ]

@[simp] lemma twoPowZ_negSucc (k : Nat) : twoPowZ (Int.negSucc k) = 1 / ((2 : ℝ) ^ k.succ) := by
  simp [twoPowZ]

namespace LedgerUnits

/-- The subgroup of ℤ generated by δ. We specialize to δ = 1 for a clean order isomorphism. -/
def DeltaSub (δ : ℤ) := {x : ℤ // ∃ n : ℤ, x = n * δ}

/-- Embed ℤ into the δ=1 subgroup. -/
def fromZ_one (n : ℤ) : DeltaSub 1 := ⟨n, by exact ⟨n, by simpa using (Int.mul_one n)⟩⟩

/-- Project from the δ=1 subgroup back to ℤ by taking its value. -/
def toZ_one (p : DeltaSub 1) : ℤ := p.val

@[simp] lemma toZ_fromZ_one (n : ℤ) : toZ_one (fromZ_one n) = n := rfl

@[simp] lemma fromZ_toZ_one (p : DeltaSub 1) : fromZ_one (toZ_one p) = p := by
  cases p with
  | mk x hx =>
    apply Subtype.ext
    rfl

/-- Explicit equivalence between the δ=1 subgroup and ℤ (mapping n·1 ↦ n). -/
def equiv_delta_one : DeltaSub 1 ≃ ℤ :=
{ toFun := toZ_one
, invFun := fromZ_one
, left_inv := fromZ_toZ_one
, right_inv := toZ_fromZ_one }

end LedgerUnits

/-‑ φ‑power wrapper and anchor parameters -/
noncomputable def PhiPow (x : ℝ) : ℝ := Real.exp (Real.log (Constants.phi) * x)

lemma PhiPow_add (x y : ℝ) : PhiPow (x + y) = PhiPow x * PhiPow y := by
  unfold PhiPow
  simpa [mul_add, Real.exp_add, mul_comm, mul_left_comm, mul_assoc]

lemma PhiPow_sub (x y : ℝ) : PhiPow (x - y) = PhiPow x / PhiPow y := by
  unfold PhiPow
  have : Real.log (Constants.phi) * (x - y)
        = Real.log (Constants.phi) * x + Real.log (Constants.phi) * (-y) := by ring
  simp [this, sub_eq_add_neg, Real.exp_add, Real.exp_neg, div_eq_mul_inv,
        mul_comm, mul_left_comm, mul_assoc]

@[simp] lemma PhiPow_zero : PhiPow 0 = 1 := by
  unfold PhiPow
  simp

@[simp] lemma PhiPow_one : PhiPow 1 = Constants.phi := by
  unfold PhiPow
  have hφ : 0 < Constants.phi := Constants.phi_pos
  simp [one_mul, Real.exp_log hφ]

@[simp] lemma PhiPow_neg (y : ℝ) : PhiPow (-y) = 1 / PhiPow y := by
  have := PhiPow_sub 0 y
  simpa [PhiPow_zero, sub_eq_add_neg] using this

@[simp] def lambdaA : ℝ := Real.log Constants.phi
@[simp] def kappaA  : ℝ := Constants.phi

@[simp] def F_ofZ (Z : ℤ) : ℝ := (Real.log (1 + (Z : ℝ) / kappaA)) / lambdaA

@[simp] def Z_quark (Q : ℤ) : ℤ := 4 + (6 * Q) ^ (2 : Nat) + (6 * Q) ^ (4 : Nat)
@[simp] def Z_lepton (Q : ℤ) : ℤ := (6 * Q) ^ (2 : Nat) + (6 * Q) ^ (4 : Nat)
@[simp] def Z_neutrino : ℤ := 0

lemma kappaA_pos : 0 < kappaA := by
  unfold kappaA
  simpa using Constants.phi_pos

lemma lambdaA_pos : 0 < lambdaA := by
  unfold lambdaA
  have : 1 < Constants.phi := Constants.one_lt_phi
  simpa using (Real.log_pos_iff.mpr this)

lemma lambdaA_ne_zero : lambdaA ≠ 0 := ne_of_gt lambdaA_pos

lemma kappaA_ne_zero : kappaA ≠ 0 := by
  simpa [kappaA] using Constants.phi_ne_zero

end RS
end RH

/-! Recognition foundations moved to submodule -/

/-! ### RS‑preserving reduction exemplar (to Vertex Cover) moved to `Complexity/*` -/

/-! Complexity.BalancedParityHidden moved to submodule -/

/‑! #### Bridge foundations (minimal) ‑/
/-! Bridge foundations moved to submodule -/

/‑! #### Tiny demo example using Recognition -/
/-! Demo moved with Recognition -/

end IndisputableMonolith
